import { Applicative, Applicative1, Applicative2, Applicative3 } from './Applicative';
import { Chain, Chain1, Chain2, Chain3 } from './Chain';
import { Functor, Functor1, Functor2, Functor3 } from './Functor';
import { HKT, Kind, Kind2, Kind3, URIS, URIS2, URIS3 } from './HKT';
import { Monad, Monad1, Monad2, Monad3 } from './Monad';
import { State } from './State';
import { Endomorphism } from './function';
export interface StateT2v<M> {
    readonly map: <S, A, B>(fa: (s: S) => HKT<M, [A, S]>, f: (a: A) => B) => (s: S) => HKT<M, [B, S]>;
    readonly of: <S, A>(a: A) => (s: S) => HKT<M, [A, S]>;
    readonly ap: <S, A, B>(fab: (s: S) => HKT<M, [(a: A) => B, S]>, fa: (s: S) => HKT<M, [A, S]>) => (s: S) => HKT<M, [B, S]>;
    readonly chain: <S, A, B>(fa: (s: S) => HKT<M, [A, S]>, f: (a: A) => (s: S) => HKT<M, [B, S]>) => (s: S) => HKT<M, [B, S]>;
}
export interface StateT2v1<M extends URIS> {
    readonly map: <S, A, B>(fa: (s: S) => Kind<M, [A, S]>, f: (a: A) => B) => (s: S) => Kind<M, [B, S]>;
    readonly of: <S, A>(a: A) => (s: S) => Kind<M, [A, S]>;
    readonly ap: <S, A, B>(fab: (s: S) => Kind<M, [(a: A) => B, S]>, fa: (s: S) => Kind<M, [A, S]>) => (s: S) => Kind<M, [B, S]>;
    readonly chain: <S, A, B>(fa: (s: S) => Kind<M, [A, S]>, f: (a: A) => (s: S) => Kind<M, [B, S]>) => (s: S) => Kind<M, [B, S]>;
}
export interface StateT2v2<M extends URIS2> {
    readonly map: <L, S, A, B>(fa: (s: S) => Kind2<M, L, [A, S]>, f: (a: A) => B) => (s: S) => Kind2<M, L, [B, S]>;
    readonly of: <L, S, A>(a: A) => (s: S) => Kind2<M, L, [A, S]>;
    readonly ap: <L, S, A, B>(fab: (s: S) => Kind2<M, L, [(a: A) => B, S]>, fa: (s: S) => Kind2<M, L, [A, S]>) => (s: S) => Kind2<M, L, [B, S]>;
    readonly chain: <L, S, A, B>(fa: (s: S) => Kind2<M, L, [A, S]>, f: (a: A) => (s: S) => Kind2<M, L, [B, S]>) => (s: S) => Kind2<M, L, [B, S]>;
}
export interface StateT2v3<M extends URIS3> {
    readonly map: <